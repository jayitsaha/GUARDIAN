# -*- coding: utf-8 -*-
"""google_genai_hackathon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PsrVThD3gpLBQcPvo6D2SWPnHWnVwazF
"""



import pandas as pd

df = pd.read_csv('social_media_data.csv',)

"""threat analysis report"""

import os
import pandas as pd
from vertexai.generative_models import GenerativeModel

# Load social media data (replace with your data source)
data = pd.read_csv("social_media_data.csv")

# Preprocess data
def clean_text(text):
    # Remove noise, normalize text, handle special characters
    # ... (implement your specific cleaning logic)
    return text

data["text"] = data["text"].apply(clean_text)

# Extract key information
def extract_username(text):
    # Use regular expressions or other methods to extract username
    # ... (implement your extraction logic)
    return username

data["username"] = data["text"].apply(extract_username)
# ... extract other information as needed

# Sentiment analysis (optional)
data["sentiment"] = data["text"].apply(lambda text: TextBlob(text).sentiment.polarity)

# Threat analysis using Vertex AI Gemini
def analyze_threat(text):
    prompt = f"Analyze the following text for potential threats: {text}"
    response = model.generate_content([prompt])

    # Process response and extract threat information
    threat_keywords = ["violence", "hate", "misinformation", ...]  # Replace with your keywords
    for keyword in threat_keywords:
        if keyword in response.lower():
            # Identify potential threat
            # ... (log, report, or take further action)

# Generate threat analysis report
def generate_report(data):
    report = {}
    report["overall_sentiment"] = data["sentiment"].mean()
    report["threats"] = []
    for index, row in data.iterrows():
        threat_info = analyze_threat(row["text"])
        if threat_info:
            report["threats"].append(threat_info)
    # ... add more report sections as needed
    return report

# Visualizations (if applicable)
def create_visualization(data):
    # ... (implement visualization logic using libraries like matplotlib or seaborn)

# Main execution
# Read API key from environment variable
api_key = os.getenv("VERTEX_AI_API_KEY")

if not api_key:
    raise ValueError("Missing VERTEX_AI_API_KEY environment variable")

# Initialize Vertex AI
vertexai.init(project="your-project-id", location="us-central1")  # Replace with your project ID and location

# Load Gemini model
model = GenerativeModel("gemini-1.5-flash-002")  # Adjust model name if needed

# Run threat analysis
report = generate_report(data)

# Print or save the report
print(report)
create_visualization(data)  # If applicable



"""fire,violence,gun detection"""

import os
import cv2
import google.generativeai as genai

# Read API key from environment variable
api_key = os.getenv("GEMINI_API_KEY")

if not api_key:
    raise ValueError("Missing GEMINI_API_KEY environment variable")

# Configure Gemini
genai.configure(api_key=api_key)

# ... rest of the code ...

import os
import cv2
import google.generativeai as genai

# Read API key from environment variable
api_key = os.getenv("GEMINI_API_KEY")

if not api_key:
    raise ValueError("Missing GEMINI_API_KEY environment variable")

# Configure Gemini
genai.configure(api_key=api_key)

# Video capture
cap = cv2.VideoCapture(0)  # Replace with video source (webcam or file)

# Define colors for bounding boxes
red = (0, 0, 255)
green = (0, 255, 0)
blue = (255, 0, 0)
yellow = (0, 255, 255)
purple = (128, 0, 128)


def detect_object(frame, object_type):
    try:
        # Replace with specific prompt for each object type
        prompt = f"Detect {object_type} and return bounding boxes (ymin, xmin, ymax, xmax)"
        response = model.generate_content([frame, prompt])

        # Process response (extract and convert bounding boxes)
        # ... (implementation depends on Gemini's output format)

        # Display frame with bounding boxes
        if "bounding_boxes" in locals():  # Check if bounding boxes exist
            color = get_color(object_type)  # Assign color based on object type
            for box in bounding_boxes:
                x_min, y_min, x_max, y_max = box
                cv2.rectangle(frame, (x_min, y_min), (x_max, y_max), color, 2)

    except Exception as e:
        print(f"Error detecting {object_type}: {e}")


def get_color(object_type):
    if object_type == "gun":
        return red
    elif object_type == "violence":
        return green
    elif object_type == "fire":
        return blue
    elif object_type == "traffic_jam":
        return yellow
    elif object_type == "construction":
        return purple
    else:
        raise ValueError(f"Unsupported object type: {object_type}")


while True:
    ret, frame = cap.read()

    # Preprocessing (if required by Gemini)
    # ... (resize, convert to RGB based on Gemini documentation)

    # Object detection (separate functions for each type)
    detect_object(frame.copy(), "gun")  # Replace .copy() if preprocessing modifies frame
    detect_object(frame.copy(), "violence")
    detect_object(frame.copy(), "fire")
    detect_object(frame.copy(), "traffic_jam")
    detect_object(frame.copy(), "construction")
    # ... add more detection functions as needed

    cv2.imshow("Object Detection", frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
